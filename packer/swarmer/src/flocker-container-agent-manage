#!/bin/bash
source "$(dirname "$0")/functions.sh"

LIB_DIR=/var/lib/flocker
CONF_DIR="$LIB_DIR"/etc

# Usage info
show_help() {
cat << EOF
Usage: ${0##*/} [-hv] start|stop|rm
Handles the lifecycle of the flocker agent service

COMMANDS:
    start              start flocker controller
    stop               stop flocker controller
    rm                 rm rkt container
OPTIONS:
    -h                 display this help and exit
    -v                 verbose mode. Can be used multiple
                       times for increased verbosity.
EOF
}

start() {
    sudo rkt run \
         --net=host \
         --hostname="$(hostname)" \
         --volume resolv,kind=host,source=/etc/resolv.conf,readOnly=false \
         --mount volume=resolv,target=/etc/resolv.conf \
         --volume conf,kind=host,source="$CONF_DIR" \
         --volume docker,kind=host,source=/var/run/docker.sock \
         --volume bootid,kind=host,source=/proc/sys/kernel/random/boot_id \
         --mount volume=bootid,target=/proc/sys/kernel/random/boot_id \
         --mount volume=conf,target=/etc/flocker \
         --mount volume=docker,target=/var/run/docker.sock \
         --uuid-file-save "$UUID_FILE" \
         clusterhq/flocker-core  --exec /bin/sh -- -c '/usr/lib/klibc/bin/umount /proc/sys/kernel/random/boot_id && /usr/sbin/flocker-container-agent'
}

if [ ! -f /etc/swarmer/swarmer.conf ]; then
    log user.error "couldn't find configuration file"
    exit 1
fi

if [ "$VOLUME_DRIVER" != "flocker" ]; then
    log user.info "flocker is disabled"
    exit 0
fi
if [ "$SWARM_MODE" != "agent" ] && [ "$SWARM_MODE" != "both" ]; then
    log user.info "not a flocker agent node: nothing to do."
    exit 0
fi
if [ ! -f /etc/swarmer/flocker-agent.yml ]; then
    log user.error "flocker-agent.yml is missing"
    exit 1
fi

mkdir -p $LIB_DIR $CONF_DIR
cp /etc/swarmer/flocker-agent.yml $CONF_DIR/agent.yml
cp /etc/swarmer/certs/ca.pem "$CONF_DIR"/cluster.crt
cp /etc/swarmer/certs/api.pem "$CONF_DIR"/node.crt
cp /etc/swarmer/certs/api-key.pem "$CONF_DIR"/node.key

OPTIND=1 # Reset is necessary if getopts was used previously in the script.  It is a good idea to make this local in a function.
while getopts ":hv:" opt; do
    case "$opt" in
        h)
            show_help
            exit 0
            ;;
        v)  verbose=$((verbose+1))
            ;;
        '?')
            show_help >&2
            exit 1
            ;;
    esac
done
shift "$((OPTIND-1))" # Shift off the options and optional --.

case $1 in
    start)
        start
        ;;
    stop)
        stop_rkt
        ;;
    rm)
        rm_rkt
        ;;
    *)
        log user.error "unknown command: $1"
        exit 1
        ;;
esac
